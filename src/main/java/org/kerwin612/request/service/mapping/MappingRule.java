package org.kerwin612.request.service.mapping;

import com.netflix.loadbalancer.ILoadBalancer;
import com.netflix.loadbalancer.Server;
import com.netflix.loadbalancer.ZoneAvoidanceRule;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryAware;
import org.springframework.util.CollectionUtils;
import org.springframework.util.ConcurrentReferenceHashMap;
import org.springframework.util.StringUtils;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * Author: kerwin612
 */
public class MappingRule extends ZoneAvoidanceRule implements BeanFactoryAware {

    private static final Logger LOGGER = LoggerFactory.getLogger(MappingRule.class);

    /**
     * regex:regex
     */
    public Map<String, String> cache = new ConcurrentReferenceHashMap<>();

    public boolean isDisable = false;

    public boolean isShort = false;

    private BeanFactory beanFactory;

    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        this.beanFactory = beanFactory;
    }

    @Override
    public Server choose(Object o) {
        String clientIP = (o != null && o instanceof String) ? (String) o : null;

        try {
            //because the MappingRule is generated by ribbon-client, so can only get the configuration instance dynamically if want to get the dynamic configuration.
            RuleConfiguration configuration = this.beanFactory.getBean(RuleConfiguration.class);
            isDisable = configuration.mappingIsDisable();
            isShort = configuration.mappingIsShort();
            cache = configuration.mappingMap();
        } catch (Exception e) {
            LOGGER.error(e.getMessage(), e);
        }

        List<String> valueMatches = StringUtils.isEmpty(clientIP) ? null : matches(clientIP);
        if (!isDisable && !CollectionUtils.isEmpty(valueMatches)) {
            ILoadBalancer lb = getLoadBalancer();
            List<Server> allServers = lb.getAllServers();
            LOGGER.info("[{}] choose from: {}", clientIP, allServers);
            for (String valueMatch : valueMatches) {
                for (Server server : allServers) {
                    String host = server.getHost();
                    if (host.matches(valueMatch)) {
                        LOGGER.info("[{}] choose value: {}", clientIP, host);
                        return server;
                    }
                }
            }
        }
        return super.choose(o);
    }

    public List<String> matches(String ip) {
        List<String> values = new ArrayList<>(0);
        Iterator<Map.Entry<String, String>> iterator = cache.entrySet().iterator();
        while (iterator.hasNext()) {
            Map.Entry<String, String> next = iterator.next();
            String key = next.getKey();
            try {
                if (ip.matches(key)) {
                    values.add(next.getValue());
                    if (isShort) break;
                }
            } catch (Exception e) {
                LOGGER.error("[{}] match error:", key, e);
            }
        }
        LOGGER.info("[{}] match values: {}; short: {}", ip, values, isShort);
        return values;
    }

}